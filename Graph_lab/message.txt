题目分析：
1.准备工作：根据题目意思，得到结构体（定义国家State结构体以及每个州（含于state数组），其中包含key序号（1-n）、boder数组表示州与哪几个周相邻，-1表示该边不与任何州相邻以及industry表示工业发达程度。自定义void init_ State(struct State *s)、void delete_ State(struct State *s)函数，来完成State的初始化和回收（释放图片的所有内存）。此外，由于像素点和州都需要坐标定位，自定义含有x和y的是像素点的坐标，含有i,j是每个六边形，即州的坐标（每个州最中间的像素坐标即为州的坐标，每跨8个像素，得到下一个州坐标）。

2.搜索工作：自定义void parse(struct State *s， struct PNG *p)函数，完成遍历整张图，给结构体填充图片信息、工业发达程度信息，以及每个州邻接情况信息。包含自定义int get_key(int i,int j,int xn)函数获取坐标为i,j的州的序号，自定义int get_industry(struct PXL *temp) 函数获取图片颜色信息，即工业发达程度信息（均用到对应的公式）。顾及每行最后一个像素点，给以下变量赋值：
xn=(p->width-1)/8;//获取每行州的个数
yn=(p->height-5)/8;//获取每列州的个数
s->n=yn/2*(2*xn-1)+(yn%2)*xn;//获取州的总个数
遍历整张图时，由于奇数、偶数行扫描其周围位置，扫描方式有所不同，定义三维数组dir[2][6][2]={{{-1,0},{-1,-1},{0,-1},{1,0},{0,1},
{-1,1}},{{-1,0},{0,-1},{1,-1},{1,0},{1,1},{0,1}}}，第三维决定是奇数行还是偶数行。前提准备完毕，最后用两个for循环嵌套完成对整张地图的扫描（如果扫描位置不是州的区域，即空白区域，则给boder数组赋值-1）。

3.最短路径：自定义int solve1(struct State *s)函数用来返回一个正确答案,代表高速公路经过的州的产业发达程度之和最小值。采用Dijkstra算法，定义N = s->n记录结点个数，d数组记录从起点到终点最少工业发达程度的和，pre数组表示路线前面一个经过的州的编号，用循环对pre、d数组初始化（将起点到各个顶点的距离设置为无穷大，起点到自身的距离设置为0）后循环遍历，从起点开始，不断选择当前距离起点最近的顶点，并更新其他顶点到起点的距离，直到找到终点或者所有顶点都被遍历完。最后返回int型变量min即为最短路径长度。

4.次短路径：自定义int solve2(struct State *s)函数用来返回一个正确答案，代表高速公路经过的州的产业发达程度之和的次小值(即次短路，注意，这里的次短路不允许重复经过同一个点)。采用Dijkstra算法，定义了常量inf为一个较大的值，N为状态列表的长度。函数中定义了一些变量，包括tempi、tempb、d、second_min和now等。其中tempi和tempb用于保存一条最短路径的边，d用于保存从起点到每个点的最短距离，min用于保存最小的最短距离，now用于保存目前距离起点最远的点，定义一个solve3函数，用于传递pre数组值到solve2，并返回firstmin到solve2。接下来的代码中使用循环来进行路径的查找和更新。该函数通过遍历路径上的每个点，删除该点与其相邻边的关系，然后使用Dijkstra算法计算从源点到终点的最短距离。在计算过程中，会记录最小值和次小值，并返回次小值作为函数的结果。

该代码定义了一个名为solve3的函数，它使用Dijkstra算法解决一个带权有向图的单源最短路径问题。
函数的参数包括一个指向struct State类型的指针s和一个指向整型数组pre的指针。s指向一个包含有关图状态的结构体，而pre是一个数组，用于存储路径上每个节点的前驱节点。

函数开始时，它声明了几个变量，包括常量inf（初始化为2147483647）表示正无穷，整型数组d和vis，并使用动态内存分配函数malloc为这两个数组分配内存。

接下来，它初始化d、vis和pre数组的元素值。它设置将所有的d数组元素初始化为inf，将所有的vis数组元素初始化为0，将所有的pre数组元素初始化为0。

然后，将起点s->n的最小发达值d[s->n]设置为0。
通过两个嵌套的for循环，使用Dijkstra算法计算从起点到每个州的最小发达值。外层循环是用于遍历所有节点，内层循环是为了找到未访问过的节点中d值最小的节点。

在内层循环中，它找到d值最小的未访问节点now，并将其标记为已访问。
然后，它遍历节点now相邻的所有节点，并更新它们的最小发达值d和前驱节点pre。
最后，函数返回起点到终点s->n的最小发达值out，并释放之前分配的动态内存。
总结而言，该函数使用Dijkstra算法计算从起点到终点的带权有向图的最短路径，并返回最短路径的长度。

该代码定义了一个名为solve1的函数，它调用了之前提到的solve3函数来解决一个带权有向图的单源最短路径问题。
函数的参数是一个指向struct State类型的指针s。
函数开始时，它声明了一个整型数组pre，并使用动态内存分配函数malloc为该数组分配内存。
然后，它调用solve3函数，将指向s的指针pre作为参数传递给solve3函数。这样做是为了在solve3函数内部记录路径上每个节点的前驱节点。
函数接着将solve3函数的返回值存储在out变量中。
最后，它释放之前分配的动态内存，释放pre数组所占用的内存，然后返回solve3函数的返回值out。
简而言之，该函数调用solve3函数来解决带权有向图的最短路径问题，并返回最短路径的长度。

该代码定义了一个名为parse的函数，用于解析一个PNG结构和一个State结构，用来表示一个州之间的连接关系。
函数的参数是指向struct State类型的指针s和指向struct PNG类型的指针p。
函数首先声明了几个变量，包括指向struct PXL类型的指针temp，整型变量xn、yn、nowx、nowy和key，以及常量x_step、y_step和x_start。
然后，函数定义了一个二维数组dir，用于存储每个州的邻接坐标变化。
接下来，函数计算州的个数并将结果存储在s->n中。
然后，函数使用动态内存分配函数malloc为s->statelist分配内存。
接下来的循环用于遍历所有的yn和xn值，以创建州的连接关系。
在循环的每次迭代中，函数计算当前州的坐标nowx和nowy，然后获取该坐标处对应的像素值temp。
接下来的循环用于计算当前州与其邻接州之间的连接关系。它通过查询dir数组中的邻接坐标变化，确定相邻州的坐标，并将相邻州的键值存储在s->statelist[key].border数组中。
最后，函数递增key的值，并继续下一个循环迭代，直到所有州都被处理完毕。
简而言之，该函数通过解析给定的PNG图像，生成表示州之间连接关系的结构体数据，并将其存储在State结构的相应字段中。

该代码定义了一个名为solve2的函数，用于解决一个State结构表示的州之间的问题。
函数的参数是指向struct State类型的指针s。
函数首先声明了一些变量，包括常量inf、N以及指向整型数组的指针d、pre、vis。
接下来，函数调用了一个名为solve3的函数，将其返回值保存在变量firstmin中。
然后，函数进入一个for循环，循环的条件是k != 1，每次迭代k的值会根据pre[k]的值更新。
在循环的每次迭代中，首先重置vis数组为未访问状态。
然后，通过遍历pre[k]所指向的州的邻接边，找到与当前州k相连的边，并将其存储在变量tempb中，并将这条边从pre[k]所指向的州中删除，即将其置为-1。
接下来，初始化数组d，将所有元素都设置为无穷大inf，但将d[1]的值设为0，表示源点的距离为0。
然后，开始通过Dijkstra算法求解最短路径。循环从1迭代到N，找到当前距离源点最远的点，并将其保存在变量now中。
在每次迭代中，如果找不到最远的点，则跳出循环。
然后，将当前点now标记为已访问。
接下来，遍历当前点的邻接边，通过更新距离数组d来更新最短路径。
在更新过程中，如果邻接边的目标点v不等于N，或者当前点到目标点的距离加上目标点的产业值不等于第一轮寻找到的最小值firstmin，则更新最短距离。
完成一轮迭代后，判断当前的最短距离d[s->n]是否小于min，如果是，则更新min的值。
最后，释放动态分配的内存，包括d、vis和pre。
函数返回最小值min。
简而言之，该函数通过Dijkstra算法寻找从源点到目标点的最短路径，并返回最小路径的值。该函数利用给定的州之间的连接关系和产业值来计算最短路径。

总结：parse的函数：用于解析一个PNG结构和一个State结构，用来表示一个州之间的连接关系。通过解析给定的PNG图像，生成表示州之间连接关系的结构体数据，并将其存储在State结构的相应字段中。
solve1的函数：调用solve3函数来解决带权有向图的最短路径问题，并返回最短路径的长度。
solve2的函数：用于解决一个State结构表示的州之间的问题。通过Dijkstra算法寻找从源点到目标点的最短路径，并返回最小路径的值。该函数利用给定的州之间的连接关系和产业值来计算最短路径。
solve3的函数：使用Dijkstra算法计算从起点到终点的带权有向图的最短路径，并返回最短路径的长度。

