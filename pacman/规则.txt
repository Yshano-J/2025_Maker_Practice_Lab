游戏简介
 
两只蒜头将在一个地图上拼命地抢分，谁最终的分数更高，谁就获得比赛的胜利。与此同时，地图上还有两个破坏者，意图破坏两只蒜头抢分，以达到自己不可告人的目的。你将要控制其中一只蒜头，运用智慧帮助你的蒜头取得比赛的胜利。接下来，我们会为你详细介绍游戏规则。
 
游戏规则
 
角色介绍
 
1. 游戏只有 2 种角色：蒜头和破坏者。
2. 每局比赛初始均有 2 只蒜头，你需要写出 AI 控制其中一只蒜头在地图上进行各种操作，而另一只蒜头将由其他同学写出的 AI 进行控制。
3. 每局比赛初始均有 2 个破坏者。
4. 保证初始时任意两个角色不会在地图的同一位置中出现。
5. 保证两个破坏者的角色对两位蒜头是绝对公平的。
 
地图介绍
 
1. 地图为 n 行 m 列由格子组成的矩阵。每个格子为以下几种类型中的一种：
- 墙：任何角色都无法移动到这种格子。
- 地面：角色可以移动到这种格子上，地面上可能有普通星和超级星。每个格子上至多会有一个星星（普通星或超级星）。
2. 各种角色的初始位置都一定是地图中的地面而非墙。
3. 保证地图对两只蒜头是绝对公平的。
4. 我们用坐标 (x - 1, y - 1) 表示地图中第 x 行 y 列的格子，即下标从 0 开始。
 
移动规则
 
1. 每个角色当前回合可以移动至上下左右四个相邻地面格子中的一个，或选择不移动。
2. 蒜头和蒜头之间、破坏者和破坏者之间不会发生碰撞。
3. 每个破坏者的移动具有一定的随机性，且会考虑破坏者到两只蒜头的最短距离（从格子 x 移动到格子 y 的最少次数，被称为 x 到 y 的最短距离，注意这并不是曼哈顿距离，因为有障碍物 ）。若某个破坏者到蒜头 A 的最短距离为 a，到蒜头 B 的最短距离为 b，则该破坏者朝蒜头 A 的方向移动的概率为 \frac{b}{a + b}，朝蒜头 B 的方向移动的概率为 \frac{a}{a + b}。注意，若有两个方向均为最短距离方向，则每概率随机选择两个方向中的一个。若有不少于一只蒜头处于强化状态或已经从地图上消失，则破坏者将会等概率随机游走。
4. 若你的 AI 没有移动到合法的下一步位置上，则会被系统认定为自杀。
 
回合介绍
 
1. 每个回合分为两部分：蒜头移动和破坏者移动。首先进行蒜头移动阶段，之后进行破坏者移动阶段。
2. 蒜头移动阶段，每只蒜头给出自己下一步移动的坐标，同时进行移动。
3. 破坏者移动阶段，每个破坏者根据确定的移动策略，同时进行移动。
 
抢分规则
 
1. 蒜头和星星重合时，星星会从地图上消失，同时蒜头增加该星星对应的分数。若同时有多只蒜头与同一星星重合，和单独相遇时增加的分数相同。
2. 蒜头和超级星重合时，蒜头会变为强化状态，并获得分数。若两只蒜头同时与超级星重合，则均变为强化状态，且获得的分数与单独相遇时增加的分数相同，具体分数会在积分规则部分介绍。
3. 破坏者和处于普通状态的蒜头重合时，蒜头会从地图上消失，并且不会再进行任何操作，称为破坏者对蒜头的抢分。
4. 破坏者和处于强化状态的蒜头重合时，破坏者会回到比赛初始时的位置。若多个强化状态的蒜头和同一破坏者重合，则和单独相遇时增加的分数相同，具体分数会在积分规则部分介绍。
5. 处于普通状态的蒜头和处于强化状态的蒜头重合时，处于普通状态的蒜头将会从地图上消失，并且不再进行任何操作，称为蒜头对蒜头的抢分。
6. 两个处于强化状态的蒜头重合时，不会发生任何事情。
 
优先级
 
以下行为按优先级从高到低排列，若两个行为同时发生，则先进行优先级更高的行为，再进行优先级更低的行为。
 
- 强化状态的蒜头对普通状态的蒜头抢分
- 强化状态的蒜头对破坏者抢分
- 破坏者对普通状态的蒜头抢分
- 蒜头收集星星
 
状态转换
 
1. 处于普通状态的蒜头与超级星重合后，该蒜头会变为强化状态，持续 20 回合（从当前回合为第一个回合开始，到第 20 个回合结束时状态消失），即为该蒜头的强化周期。
2. 处于强化状态的蒜头与超级星重合后，则将强化状态的剩余持续回合数刷新至 20。
3. 破坏者被蒜头吃掉后回到初始位置时，有持续至接下来蒜头或破坏者的一次移动完成的强化期，即在强化期内，破坏者不会被处于强化状态的蒜头抢分。
4. 回合数从当前回合开始计算，即当前回合为强化周期的倒数第 20 回合。
 
计分规则
 
1. 每个回合结束时，所有未从地图上消失的蒜头同时扣 1 分。
2. 蒜头与一个普通星重合，增加 10 分。
3. 蒜头与一个超级星重合，增加 10 分。
4. 蒜头被破坏者抢分，扣掉 500 分。
5. 强化状态的蒜头与破坏者重合，增加 200 分。
6. 蒜头 A 被蒜头 B 抢分，则蒜头 A 将自己分数 score_A 的一半下取整（即 \lfloor \frac{score_A}{2} \rfloor ）转移至蒜头 B。
7. 蒜头自杀，扣 400 分。

结束条件
 
满足以下条件之一时，游戏结束：
 
1. 两只蒜头均已从地图上消失；
2. 游戏已进行了 n \times m 回合，其中 n 和 m 分别为地图的行数和列数；
3. 地图上的星星全部消失。
 
目录概览
 
- bin
  |-- check_computer
  |-- check_player
  |-- computer
  |-- judge
  |-- player
- code
  |-- computer.h
  |-- player.h
- data
  |-- map.txt
- include
  |-- playerbase.h
- lib
  |-- libplayer.a
- log
- Makefile
- run.sh
- src
  |-- check_computer.c
  |-- check_player.c
  |-- main_computer.c
  |-- main_player.c
 
 
你需要在  code/player.h  文件中实现你的 AI 算法。不要随意修改  Makefile  文件、其他的脚本和头文件，这些文件都将会在评测时被原始版本覆盖。
 
请将所有代码逻辑都实现在该文件内，我们评测时只保留  player.h  代码，其余代码将会被评测系统的代码替换。
 
对战时将会把双方的代码分别命名为  computer.h  和  player.h ，先后顺序见赛事介绍部分。我们会确保先后手不会对对战结果产生影响。
 
地图格式
 
 data/map.txt  为一个供你测试的 10×10 的地图。第一行为两个整数 n,m，分别表示矩阵的行数和列数。接下来一共 n 行，每行 m 个字符，表示地图每个格子的类型信息。每个格子的类型和对应的符号如下表：
 
类型 符号 
墙 # 
带有普通星的地面 o（小写字母 o） 
带有超级星的地面 O（大写字母 O） 
地面 . 
 
接下来四行，每行两个整数，分别表示第一个破坏者、第二个破坏者、你的对手控制的选手、你控制的选手的初始坐标 (x,y)，其中第一个整数为初始行第，第二个整数为初始列数，均从 0 开始编号。
 
除此以外，还提供了 13×15、30×30、41×41、50×50、60×60 的地图供测试，你可以将地图内的数据拷贝到  data/map.txt  中进行测试。
 
PlayerBase 结构体
 
struct Player {
    char **mat; // Game Data

    int row_cnt; // Count of rows in current map
    int col_cnt; // Count of columns in current map

    int ghost_posx[2]; // X-coordinate of 2 ghosts' position, index from 0
    int ghost_posy[2]; // Y-coordinate of 2 ghosts' position, index from 0

    int your_posx; // X-coordinate of your AI's position, index from 0
    int your_posy; // Y-coordinate of your AI's position, index from 0

    int opponent_posx; // X-coordinate of opponent AI's position, index from 0
    int opponent_posy; // Y-coordinate of opponent AI's position, index from 0

    int your_status; // Your AI's status, -1 means died, x(x > 0) means your AI's super status will sustain in x more rounds, 0 means normal status.
    int opponent_status; // Opponent AI's status, -1 means died, x(x > 0) means opponent AI's super status will sustain in x more rounds, 0 means normal status.

    int your_score; // Your AI's score
    int opponent_score; // Opponent AI's score
};

struct Point walk(struct Player *player); // You need to implement
void init(struct Player *player); // init function
 
 
测试运行
 
执行  ./run.sh  脚本即可测试。可以在  logs  目录内查看游戏过程和最终分数。
 
可以执行  ./run.sh --visible  进行可视化测试。
 
时间限制
 
1. 初始化的时间限制为 1s。
2. 每回合移动的计算时间限制为 100ms。
3. 若回合移动的计算超时，则系统会认为此次不移动。
4. 我们会确保在最终评测时，如果选手的程序在机器上可以在时间限制内跑完结果，那么一定能在评测机上获得符合预期的结果。
 
空间限制
 
空间限制为 256MB，于最终评测时进行限制。
 
函数调用限制

以下系统调用及函数禁止使用
 
1. 新建进程（调用 fork ）
​
2. 禁止读写文件
​
3. 禁止调用 PlayerBase 类的 _recv、_send、_work、_init_thread、_walk_thread、_syscall_check 方法。
 
程序异常处理
 
若 AI 进程在某次 walk 计算时异常退出，则系统会认为此次不移动。
 
程序异常退出或运行超时会导致数据恢复为上一回合时的状态。
